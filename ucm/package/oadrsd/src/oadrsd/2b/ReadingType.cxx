// Copyright (c) 2005-2011 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#include <xsd/cxx/pre.hxx>

// Begin prologue.
//
//
// End prologue.

#include "ReadingType.hxx"

#include "AccumulationKind.hxx"

#include "CommodityKind.hxx"

#include "Int16.hxx"

#include "Currency.hxx"

#include "DataQualifierKind.hxx"

#include "QualityOfReading.hxx"

#include "FlowDirectionKind.hxx"

#include "UInt32.hxx"

#include "MeasurementKind.hxx"

#include "PhaseCodeKind.hxx"

#include "UnitMultiplierKind.hxx"

#include "TimePeriodOfInterest.hxx"

#include "UnitSymbolKind.hxx"

#include "ReadingInterharmonic.hxx"

#include "TimeAttributeKind.hxx"

#include "RationalNumber.hxx"

namespace espi
{
  // ReadingType
  // 

  const ReadingType::accumulationBehaviour_optional& ReadingType::
  accumulationBehaviour () const
  {
    return this->accumulationBehaviour_;
  }

  ReadingType::accumulationBehaviour_optional& ReadingType::
  accumulationBehaviour ()
  {
    return this->accumulationBehaviour_;
  }

  void ReadingType::
  accumulationBehaviour (const accumulationBehaviour_type& x)
  {
    this->accumulationBehaviour_.set (x);
  }

  void ReadingType::
  accumulationBehaviour (const accumulationBehaviour_optional& x)
  {
    this->accumulationBehaviour_ = x;
  }

  void ReadingType::
  accumulationBehaviour (::std::auto_ptr< accumulationBehaviour_type > x)
  {
    this->accumulationBehaviour_.set (x);
  }

  const ReadingType::commodity_optional& ReadingType::
  commodity () const
  {
    return this->commodity_;
  }

  ReadingType::commodity_optional& ReadingType::
  commodity ()
  {
    return this->commodity_;
  }

  void ReadingType::
  commodity (const commodity_type& x)
  {
    this->commodity_.set (x);
  }

  void ReadingType::
  commodity (const commodity_optional& x)
  {
    this->commodity_ = x;
  }

  void ReadingType::
  commodity (::std::auto_ptr< commodity_type > x)
  {
    this->commodity_.set (x);
  }

  const ReadingType::consumptionTier_optional& ReadingType::
  consumptionTier () const
  {
    return this->consumptionTier_;
  }

  ReadingType::consumptionTier_optional& ReadingType::
  consumptionTier ()
  {
    return this->consumptionTier_;
  }

  void ReadingType::
  consumptionTier (const consumptionTier_type& x)
  {
    this->consumptionTier_.set (x);
  }

  void ReadingType::
  consumptionTier (const consumptionTier_optional& x)
  {
    this->consumptionTier_ = x;
  }

  void ReadingType::
  consumptionTier (::std::auto_ptr< consumptionTier_type > x)
  {
    this->consumptionTier_.set (x);
  }

  const ReadingType::currency_optional& ReadingType::
  currency () const
  {
    return this->currency_;
  }

  ReadingType::currency_optional& ReadingType::
  currency ()
  {
    return this->currency_;
  }

  void ReadingType::
  currency (const currency_type& x)
  {
    this->currency_.set (x);
  }

  void ReadingType::
  currency (const currency_optional& x)
  {
    this->currency_ = x;
  }

  void ReadingType::
  currency (::std::auto_ptr< currency_type > x)
  {
    this->currency_.set (x);
  }

  const ReadingType::dataQualifier_optional& ReadingType::
  dataQualifier () const
  {
    return this->dataQualifier_;
  }

  ReadingType::dataQualifier_optional& ReadingType::
  dataQualifier ()
  {
    return this->dataQualifier_;
  }

  void ReadingType::
  dataQualifier (const dataQualifier_type& x)
  {
    this->dataQualifier_.set (x);
  }

  void ReadingType::
  dataQualifier (const dataQualifier_optional& x)
  {
    this->dataQualifier_ = x;
  }

  void ReadingType::
  dataQualifier (::std::auto_ptr< dataQualifier_type > x)
  {
    this->dataQualifier_.set (x);
  }

  const ReadingType::defaultQuality_optional& ReadingType::
  defaultQuality () const
  {
    return this->defaultQuality_;
  }

  ReadingType::defaultQuality_optional& ReadingType::
  defaultQuality ()
  {
    return this->defaultQuality_;
  }

  void ReadingType::
  defaultQuality (const defaultQuality_type& x)
  {
    this->defaultQuality_.set (x);
  }

  void ReadingType::
  defaultQuality (const defaultQuality_optional& x)
  {
    this->defaultQuality_ = x;
  }

  void ReadingType::
  defaultQuality (::std::auto_ptr< defaultQuality_type > x)
  {
    this->defaultQuality_.set (x);
  }

  const ReadingType::flowDirection_optional& ReadingType::
  flowDirection () const
  {
    return this->flowDirection_;
  }

  ReadingType::flowDirection_optional& ReadingType::
  flowDirection ()
  {
    return this->flowDirection_;
  }

  void ReadingType::
  flowDirection (const flowDirection_type& x)
  {
    this->flowDirection_.set (x);
  }

  void ReadingType::
  flowDirection (const flowDirection_optional& x)
  {
    this->flowDirection_ = x;
  }

  void ReadingType::
  flowDirection (::std::auto_ptr< flowDirection_type > x)
  {
    this->flowDirection_.set (x);
  }

  const ReadingType::intervalLength_optional& ReadingType::
  intervalLength () const
  {
    return this->intervalLength_;
  }

  ReadingType::intervalLength_optional& ReadingType::
  intervalLength ()
  {
    return this->intervalLength_;
  }

  void ReadingType::
  intervalLength (const intervalLength_type& x)
  {
    this->intervalLength_.set (x);
  }

  void ReadingType::
  intervalLength (const intervalLength_optional& x)
  {
    this->intervalLength_ = x;
  }

  void ReadingType::
  intervalLength (::std::auto_ptr< intervalLength_type > x)
  {
    this->intervalLength_.set (x);
  }

  const ReadingType::kind_optional& ReadingType::
  kind () const
  {
    return this->kind_;
  }

  ReadingType::kind_optional& ReadingType::
  kind ()
  {
    return this->kind_;
  }

  void ReadingType::
  kind (const kind_type& x)
  {
    this->kind_.set (x);
  }

  void ReadingType::
  kind (const kind_optional& x)
  {
    this->kind_ = x;
  }

  void ReadingType::
  kind (::std::auto_ptr< kind_type > x)
  {
    this->kind_.set (x);
  }

  const ReadingType::phase_optional& ReadingType::
  phase () const
  {
    return this->phase_;
  }

  ReadingType::phase_optional& ReadingType::
  phase ()
  {
    return this->phase_;
  }

  void ReadingType::
  phase (const phase_type& x)
  {
    this->phase_.set (x);
  }

  void ReadingType::
  phase (const phase_optional& x)
  {
    this->phase_ = x;
  }

  void ReadingType::
  phase (::std::auto_ptr< phase_type > x)
  {
    this->phase_.set (x);
  }

  const ReadingType::powerOfTenMultiplier_optional& ReadingType::
  powerOfTenMultiplier () const
  {
    return this->powerOfTenMultiplier_;
  }

  ReadingType::powerOfTenMultiplier_optional& ReadingType::
  powerOfTenMultiplier ()
  {
    return this->powerOfTenMultiplier_;
  }

  void ReadingType::
  powerOfTenMultiplier (const powerOfTenMultiplier_type& x)
  {
    this->powerOfTenMultiplier_.set (x);
  }

  void ReadingType::
  powerOfTenMultiplier (const powerOfTenMultiplier_optional& x)
  {
    this->powerOfTenMultiplier_ = x;
  }

  void ReadingType::
  powerOfTenMultiplier (::std::auto_ptr< powerOfTenMultiplier_type > x)
  {
    this->powerOfTenMultiplier_.set (x);
  }

  const ReadingType::timeAttribute_optional& ReadingType::
  timeAttribute () const
  {
    return this->timeAttribute_;
  }

  ReadingType::timeAttribute_optional& ReadingType::
  timeAttribute ()
  {
    return this->timeAttribute_;
  }

  void ReadingType::
  timeAttribute (const timeAttribute_type& x)
  {
    this->timeAttribute_.set (x);
  }

  void ReadingType::
  timeAttribute (const timeAttribute_optional& x)
  {
    this->timeAttribute_ = x;
  }

  void ReadingType::
  timeAttribute (::std::auto_ptr< timeAttribute_type > x)
  {
    this->timeAttribute_.set (x);
  }

  const ReadingType::tou_optional& ReadingType::
  tou () const
  {
    return this->tou_;
  }

  ReadingType::tou_optional& ReadingType::
  tou ()
  {
    return this->tou_;
  }

  void ReadingType::
  tou (const tou_type& x)
  {
    this->tou_.set (x);
  }

  void ReadingType::
  tou (const tou_optional& x)
  {
    this->tou_ = x;
  }

  void ReadingType::
  tou (::std::auto_ptr< tou_type > x)
  {
    this->tou_.set (x);
  }

  const ReadingType::uom_optional& ReadingType::
  uom () const
  {
    return this->uom_;
  }

  ReadingType::uom_optional& ReadingType::
  uom ()
  {
    return this->uom_;
  }

  void ReadingType::
  uom (const uom_type& x)
  {
    this->uom_.set (x);
  }

  void ReadingType::
  uom (const uom_optional& x)
  {
    this->uom_ = x;
  }

  void ReadingType::
  uom (::std::auto_ptr< uom_type > x)
  {
    this->uom_.set (x);
  }

  const ReadingType::cpp_optional& ReadingType::
  cpp () const
  {
    return this->cpp_;
  }

  ReadingType::cpp_optional& ReadingType::
  cpp ()
  {
    return this->cpp_;
  }

  void ReadingType::
  cpp (const cpp_type& x)
  {
    this->cpp_.set (x);
  }

  void ReadingType::
  cpp (const cpp_optional& x)
  {
    this->cpp_ = x;
  }

  void ReadingType::
  cpp (::std::auto_ptr< cpp_type > x)
  {
    this->cpp_.set (x);
  }

  const ReadingType::interharmonic_optional& ReadingType::
  interharmonic () const
  {
    return this->interharmonic_;
  }

  ReadingType::interharmonic_optional& ReadingType::
  interharmonic ()
  {
    return this->interharmonic_;
  }

  void ReadingType::
  interharmonic (const interharmonic_type& x)
  {
    this->interharmonic_.set (x);
  }

  void ReadingType::
  interharmonic (const interharmonic_optional& x)
  {
    this->interharmonic_ = x;
  }

  void ReadingType::
  interharmonic (::std::auto_ptr< interharmonic_type > x)
  {
    this->interharmonic_.set (x);
  }

  const ReadingType::measuringPeriod_optional& ReadingType::
  measuringPeriod () const
  {
    return this->measuringPeriod_;
  }

  ReadingType::measuringPeriod_optional& ReadingType::
  measuringPeriod ()
  {
    return this->measuringPeriod_;
  }

  void ReadingType::
  measuringPeriod (const measuringPeriod_type& x)
  {
    this->measuringPeriod_.set (x);
  }

  void ReadingType::
  measuringPeriod (const measuringPeriod_optional& x)
  {
    this->measuringPeriod_ = x;
  }

  void ReadingType::
  measuringPeriod (::std::auto_ptr< measuringPeriod_type > x)
  {
    this->measuringPeriod_.set (x);
  }

  const ReadingType::argument_optional& ReadingType::
  argument () const
  {
    return this->argument_;
  }

  ReadingType::argument_optional& ReadingType::
  argument ()
  {
    return this->argument_;
  }

  void ReadingType::
  argument (const argument_type& x)
  {
    this->argument_.set (x);
  }

  void ReadingType::
  argument (const argument_optional& x)
  {
    this->argument_ = x;
  }

  void ReadingType::
  argument (::std::auto_ptr< argument_type > x)
  {
    this->argument_.set (x);
  }
}

#include <xsd/cxx/xml/dom/parsing-source.hxx>

#include <xsd/cxx/tree/type-factory-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_factory_plate< 0, char >
  type_factory_plate_init;
}

namespace espi
{
  // ReadingType
  //

  ReadingType::
  ReadingType ()
  : ::espi::IdentifiedObject (),
    accumulationBehaviour_ (this),
    commodity_ (this),
    consumptionTier_ (this),
    currency_ (this),
    dataQualifier_ (this),
    defaultQuality_ (this),
    flowDirection_ (this),
    intervalLength_ (this),
    kind_ (this),
    phase_ (this),
    powerOfTenMultiplier_ (this),
    timeAttribute_ (this),
    tou_ (this),
    uom_ (this),
    cpp_ (this),
    interharmonic_ (this),
    measuringPeriod_ (this),
    argument_ (this)
  {
  }

  ReadingType::
  ReadingType (const ReadingType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::espi::IdentifiedObject (x, f, c),
    accumulationBehaviour_ (x.accumulationBehaviour_, f, this),
    commodity_ (x.commodity_, f, this),
    consumptionTier_ (x.consumptionTier_, f, this),
    currency_ (x.currency_, f, this),
    dataQualifier_ (x.dataQualifier_, f, this),
    defaultQuality_ (x.defaultQuality_, f, this),
    flowDirection_ (x.flowDirection_, f, this),
    intervalLength_ (x.intervalLength_, f, this),
    kind_ (x.kind_, f, this),
    phase_ (x.phase_, f, this),
    powerOfTenMultiplier_ (x.powerOfTenMultiplier_, f, this),
    timeAttribute_ (x.timeAttribute_, f, this),
    tou_ (x.tou_, f, this),
    uom_ (x.uom_, f, this),
    cpp_ (x.cpp_, f, this),
    interharmonic_ (x.interharmonic_, f, this),
    measuringPeriod_ (x.measuringPeriod_, f, this),
    argument_ (x.argument_, f, this)
  {
  }

  ReadingType::
  ReadingType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
  : ::espi::IdentifiedObject (e, f | ::xml_schema::flags::base, c),
    accumulationBehaviour_ (this),
    commodity_ (this),
    consumptionTier_ (this),
    currency_ (this),
    dataQualifier_ (this),
    defaultQuality_ (this),
    flowDirection_ (this),
    intervalLength_ (this),
    kind_ (this),
    phase_ (this),
    powerOfTenMultiplier_ (this),
    timeAttribute_ (this),
    tou_ (this),
    uom_ (this),
    cpp_ (this),
    interharmonic_ (this),
    measuringPeriod_ (this),
    argument_ (this)
  {
    if ((f & ::xml_schema::flags::base) == 0)
    {
      ::xsd::cxx::xml::dom::parser< char > p (e, true, false);
      this->parse (p, f);
    }
  }

  void ReadingType::
  parse (::xsd::cxx::xml::dom::parser< char >& p,
         ::xml_schema::flags f)
  {
    this->::espi::IdentifiedObject::parse (p, f);

    for (; p.more_elements (); p.next_element ())
    {
      const ::xercesc::DOMElement& i (p.cur_element ());
      const ::xsd::cxx::xml::qualified_name< char > n (
        ::xsd::cxx::xml::dom::name< char > (i));

      // accumulationBehaviour
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "accumulationBehaviour",
            "http://naesb.org/espi",
            &::xsd::cxx::tree::factory_impl< accumulationBehaviour_type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->accumulationBehaviour_)
          {
            ::std::auto_ptr< accumulationBehaviour_type > r (
              dynamic_cast< accumulationBehaviour_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->accumulationBehaviour_.set (r);
            continue;
          }
        }
      }

      // commodity
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "commodity",
            "http://naesb.org/espi",
            &::xsd::cxx::tree::factory_impl< commodity_type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->commodity_)
          {
            ::std::auto_ptr< commodity_type > r (
              dynamic_cast< commodity_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->commodity_.set (r);
            continue;
          }
        }
      }

      // consumptionTier
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "consumptionTier",
            "http://naesb.org/espi",
            &::xsd::cxx::tree::factory_impl< consumptionTier_type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->consumptionTier_)
          {
            ::std::auto_ptr< consumptionTier_type > r (
              dynamic_cast< consumptionTier_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->consumptionTier_.set (r);
            continue;
          }
        }
      }

      // currency
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "currency",
            "http://naesb.org/espi",
            &::xsd::cxx::tree::factory_impl< currency_type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->currency_)
          {
            ::std::auto_ptr< currency_type > r (
              dynamic_cast< currency_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->currency_.set (r);
            continue;
          }
        }
      }

      // dataQualifier
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "dataQualifier",
            "http://naesb.org/espi",
            &::xsd::cxx::tree::factory_impl< dataQualifier_type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->dataQualifier_)
          {
            ::std::auto_ptr< dataQualifier_type > r (
              dynamic_cast< dataQualifier_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->dataQualifier_.set (r);
            continue;
          }
        }
      }

      // defaultQuality
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "defaultQuality",
            "http://naesb.org/espi",
            &::xsd::cxx::tree::factory_impl< defaultQuality_type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->defaultQuality_)
          {
            ::std::auto_ptr< defaultQuality_type > r (
              dynamic_cast< defaultQuality_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->defaultQuality_.set (r);
            continue;
          }
        }
      }

      // flowDirection
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "flowDirection",
            "http://naesb.org/espi",
            &::xsd::cxx::tree::factory_impl< flowDirection_type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->flowDirection_)
          {
            ::std::auto_ptr< flowDirection_type > r (
              dynamic_cast< flowDirection_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->flowDirection_.set (r);
            continue;
          }
        }
      }

      // intervalLength
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "intervalLength",
            "http://naesb.org/espi",
            &::xsd::cxx::tree::factory_impl< intervalLength_type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->intervalLength_)
          {
            ::std::auto_ptr< intervalLength_type > r (
              dynamic_cast< intervalLength_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->intervalLength_.set (r);
            continue;
          }
        }
      }

      // kind
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "kind",
            "http://naesb.org/espi",
            &::xsd::cxx::tree::factory_impl< kind_type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->kind_)
          {
            ::std::auto_ptr< kind_type > r (
              dynamic_cast< kind_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->kind_.set (r);
            continue;
          }
        }
      }

      // phase
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "phase",
            "http://naesb.org/espi",
            &::xsd::cxx::tree::factory_impl< phase_type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->phase_)
          {
            ::std::auto_ptr< phase_type > r (
              dynamic_cast< phase_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->phase_.set (r);
            continue;
          }
        }
      }

      // powerOfTenMultiplier
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "powerOfTenMultiplier",
            "http://naesb.org/espi",
            &::xsd::cxx::tree::factory_impl< powerOfTenMultiplier_type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->powerOfTenMultiplier_)
          {
            ::std::auto_ptr< powerOfTenMultiplier_type > r (
              dynamic_cast< powerOfTenMultiplier_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->powerOfTenMultiplier_.set (r);
            continue;
          }
        }
      }

      // timeAttribute
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "timeAttribute",
            "http://naesb.org/espi",
            &::xsd::cxx::tree::factory_impl< timeAttribute_type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->timeAttribute_)
          {
            ::std::auto_ptr< timeAttribute_type > r (
              dynamic_cast< timeAttribute_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->timeAttribute_.set (r);
            continue;
          }
        }
      }

      // tou
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "tou",
            "http://naesb.org/espi",
            &::xsd::cxx::tree::factory_impl< tou_type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->tou_)
          {
            ::std::auto_ptr< tou_type > r (
              dynamic_cast< tou_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->tou_.set (r);
            continue;
          }
        }
      }

      // uom
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "uom",
            "http://naesb.org/espi",
            &::xsd::cxx::tree::factory_impl< uom_type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->uom_)
          {
            ::std::auto_ptr< uom_type > r (
              dynamic_cast< uom_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->uom_.set (r);
            continue;
          }
        }
      }

      // cpp
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "cpp",
            "http://naesb.org/espi",
            &::xsd::cxx::tree::factory_impl< cpp_type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->cpp_)
          {
            ::std::auto_ptr< cpp_type > r (
              dynamic_cast< cpp_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->cpp_.set (r);
            continue;
          }
        }
      }

      // interharmonic
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "interharmonic",
            "http://naesb.org/espi",
            &::xsd::cxx::tree::factory_impl< interharmonic_type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->interharmonic_)
          {
            ::std::auto_ptr< interharmonic_type > r (
              dynamic_cast< interharmonic_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->interharmonic_.set (r);
            continue;
          }
        }
      }

      // measuringPeriod
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "measuringPeriod",
            "http://naesb.org/espi",
            &::xsd::cxx::tree::factory_impl< measuringPeriod_type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->measuringPeriod_)
          {
            ::std::auto_ptr< measuringPeriod_type > r (
              dynamic_cast< measuringPeriod_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->measuringPeriod_.set (r);
            continue;
          }
        }
      }

      // argument
      //
      {
        ::std::auto_ptr< ::xsd::cxx::tree::type > tmp (
          ::xsd::cxx::tree::type_factory_map_instance< 0, char > ().create (
            "argument",
            "http://naesb.org/espi",
            &::xsd::cxx::tree::factory_impl< argument_type >,
            false, true, i, n, f, this));

        if (tmp.get () != 0)
        {
          if (!this->argument_)
          {
            ::std::auto_ptr< argument_type > r (
              dynamic_cast< argument_type* > (tmp.get ()));

            if (r.get ())
              tmp.release ();
            else
              throw ::xsd::cxx::tree::not_derived< char > ();

            this->argument_.set (r);
            continue;
          }
        }
      }

      break;
    }
  }

  ReadingType* ReadingType::
  _clone (::xml_schema::flags f,
          ::xml_schema::container* c) const
  {
    return new class ReadingType (*this, f, c);
  }

  ReadingType& ReadingType::
  operator= (const ReadingType& x)
  {
    if (this != &x)
    {
      static_cast< ::espi::IdentifiedObject& > (*this) = x;
      this->accumulationBehaviour_ = x.accumulationBehaviour_;
      this->commodity_ = x.commodity_;
      this->consumptionTier_ = x.consumptionTier_;
      this->currency_ = x.currency_;
      this->dataQualifier_ = x.dataQualifier_;
      this->defaultQuality_ = x.defaultQuality_;
      this->flowDirection_ = x.flowDirection_;
      this->intervalLength_ = x.intervalLength_;
      this->kind_ = x.kind_;
      this->phase_ = x.phase_;
      this->powerOfTenMultiplier_ = x.powerOfTenMultiplier_;
      this->timeAttribute_ = x.timeAttribute_;
      this->tou_ = x.tou_;
      this->uom_ = x.uom_;
      this->cpp_ = x.cpp_;
      this->interharmonic_ = x.interharmonic_;
      this->measuringPeriod_ = x.measuringPeriod_;
      this->argument_ = x.argument_;
    }

    return *this;
  }

  ReadingType::
  ~ReadingType ()
  {
  }

  static
  const ::xsd::cxx::tree::type_factory_initializer< 0, char, ReadingType >
  _xsd_ReadingType_type_factory_init (
    "ReadingType",
    "http://naesb.org/espi");
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

namespace espi
{
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

#include <xsd/cxx/tree/type-serializer-map.hxx>

namespace _xsd
{
  static
  const ::xsd::cxx::tree::type_serializer_plate< 0, char >
  type_serializer_plate_init;
}

namespace espi
{
  void
  operator<< (::xercesc::DOMElement& e, const ReadingType& i)
  {
    e << static_cast< const ::espi::IdentifiedObject& > (i);

    // accumulationBehaviour
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.accumulationBehaviour ())
      {
        const ReadingType::accumulationBehaviour_type& x (*i.accumulationBehaviour ());
        if (typeid (ReadingType::accumulationBehaviour_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "accumulationBehaviour",
              "http://naesb.org/espi",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "accumulationBehaviour",
            "http://naesb.org/espi",
            false, true, e, x);
      }
    }

    // commodity
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.commodity ())
      {
        const ReadingType::commodity_type& x (*i.commodity ());
        if (typeid (ReadingType::commodity_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "commodity",
              "http://naesb.org/espi",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "commodity",
            "http://naesb.org/espi",
            false, true, e, x);
      }
    }

    // consumptionTier
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.consumptionTier ())
      {
        const ReadingType::consumptionTier_type& x (*i.consumptionTier ());
        if (typeid (ReadingType::consumptionTier_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "consumptionTier",
              "http://naesb.org/espi",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "consumptionTier",
            "http://naesb.org/espi",
            false, true, e, x);
      }
    }

    // currency
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.currency ())
      {
        const ReadingType::currency_type& x (*i.currency ());
        if (typeid (ReadingType::currency_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "currency",
              "http://naesb.org/espi",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "currency",
            "http://naesb.org/espi",
            false, true, e, x);
      }
    }

    // dataQualifier
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.dataQualifier ())
      {
        const ReadingType::dataQualifier_type& x (*i.dataQualifier ());
        if (typeid (ReadingType::dataQualifier_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "dataQualifier",
              "http://naesb.org/espi",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "dataQualifier",
            "http://naesb.org/espi",
            false, true, e, x);
      }
    }

    // defaultQuality
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.defaultQuality ())
      {
        const ReadingType::defaultQuality_type& x (*i.defaultQuality ());
        if (typeid (ReadingType::defaultQuality_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "defaultQuality",
              "http://naesb.org/espi",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "defaultQuality",
            "http://naesb.org/espi",
            false, true, e, x);
      }
    }

    // flowDirection
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.flowDirection ())
      {
        const ReadingType::flowDirection_type& x (*i.flowDirection ());
        if (typeid (ReadingType::flowDirection_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "flowDirection",
              "http://naesb.org/espi",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "flowDirection",
            "http://naesb.org/espi",
            false, true, e, x);
      }
    }

    // intervalLength
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.intervalLength ())
      {
        const ReadingType::intervalLength_type& x (*i.intervalLength ());
        if (typeid (ReadingType::intervalLength_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "intervalLength",
              "http://naesb.org/espi",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "intervalLength",
            "http://naesb.org/espi",
            false, true, e, x);
      }
    }

    // kind
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.kind ())
      {
        const ReadingType::kind_type& x (*i.kind ());
        if (typeid (ReadingType::kind_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "kind",
              "http://naesb.org/espi",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "kind",
            "http://naesb.org/espi",
            false, true, e, x);
      }
    }

    // phase
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.phase ())
      {
        const ReadingType::phase_type& x (*i.phase ());
        if (typeid (ReadingType::phase_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "phase",
              "http://naesb.org/espi",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "phase",
            "http://naesb.org/espi",
            false, true, e, x);
      }
    }

    // powerOfTenMultiplier
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.powerOfTenMultiplier ())
      {
        const ReadingType::powerOfTenMultiplier_type& x (*i.powerOfTenMultiplier ());
        if (typeid (ReadingType::powerOfTenMultiplier_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "powerOfTenMultiplier",
              "http://naesb.org/espi",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "powerOfTenMultiplier",
            "http://naesb.org/espi",
            false, true, e, x);
      }
    }

    // timeAttribute
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.timeAttribute ())
      {
        const ReadingType::timeAttribute_type& x (*i.timeAttribute ());
        if (typeid (ReadingType::timeAttribute_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "timeAttribute",
              "http://naesb.org/espi",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "timeAttribute",
            "http://naesb.org/espi",
            false, true, e, x);
      }
    }

    // tou
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.tou ())
      {
        const ReadingType::tou_type& x (*i.tou ());
        if (typeid (ReadingType::tou_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "tou",
              "http://naesb.org/espi",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "tou",
            "http://naesb.org/espi",
            false, true, e, x);
      }
    }

    // uom
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.uom ())
      {
        const ReadingType::uom_type& x (*i.uom ());
        if (typeid (ReadingType::uom_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "uom",
              "http://naesb.org/espi",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "uom",
            "http://naesb.org/espi",
            false, true, e, x);
      }
    }

    // cpp
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.cpp ())
      {
        const ReadingType::cpp_type& x (*i.cpp ());
        if (typeid (ReadingType::cpp_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "cpp",
              "http://naesb.org/espi",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "cpp",
            "http://naesb.org/espi",
            false, true, e, x);
      }
    }

    // interharmonic
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.interharmonic ())
      {
        const ReadingType::interharmonic_type& x (*i.interharmonic ());
        if (typeid (ReadingType::interharmonic_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "interharmonic",
              "http://naesb.org/espi",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "interharmonic",
            "http://naesb.org/espi",
            false, true, e, x);
      }
    }

    // measuringPeriod
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.measuringPeriod ())
      {
        const ReadingType::measuringPeriod_type& x (*i.measuringPeriod ());
        if (typeid (ReadingType::measuringPeriod_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "measuringPeriod",
              "http://naesb.org/espi",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "measuringPeriod",
            "http://naesb.org/espi",
            false, true, e, x);
      }
    }

    // argument
    //
    {
      ::xsd::cxx::tree::type_serializer_map< char >& tsm (
        ::xsd::cxx::tree::type_serializer_map_instance< 0, char > ());

      if (i.argument ())
      {
        const ReadingType::argument_type& x (*i.argument ());
        if (typeid (ReadingType::argument_type) == typeid (x))
        {
          ::xercesc::DOMElement& s (
            ::xsd::cxx::xml::dom::create_element (
              "argument",
              "http://naesb.org/espi",
              e));

          s << x;
        }
        else
          tsm.serialize (
            "argument",
            "http://naesb.org/espi",
            false, true, e, x);
      }
    }
  }

  static
  const ::xsd::cxx::tree::type_serializer_initializer< 0, char, ReadingType >
  _xsd_ReadingType_type_serializer_init (
    "ReadingType",
    "http://naesb.org/espi");
}

// Begin epilogue.
//
//
// End epilogue.

#include <xsd/cxx/post.hxx>

